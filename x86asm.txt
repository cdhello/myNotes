asm
第2章
8086   16位处理器
AX(AH+AL) BX(BH+BL) CX(CH+CL) DX(DH+DL) SI DI BP SP 8个16位通用寄存器，前4个如括号里的，
CS DS ES SS 4个段寄存器  C是code， D是data， E是附加（extra)， S是stack
IP 指令寄存器（Instruction Pointer）
20位地址线

为什么分段
分段是为了解决重定位问题。
程序中如果使用的是物理地址，那就在每次运行时都要求对应地址可用。分段就是让程序使用偏移地址，而不是绝对地址。
每次加载程序时，把code加载起始地址赋到CS，IP里放Code的段内偏移，就可以对code进行寻址。
Data加载起始地址赋到DS，DS配合code里存在的相对data偏移，就可以对Data进行寻址。

具体到8086，段寄存器是16位，地址线是20位。这里是把data或code的加载地址的高16位放到段寄存器中，因此，要求加载地址低4位为0。


附
http://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html
通用寄存器：

AX，BX，CX，DX 称作为数据寄存器：
    AX (Accumulator)：累加寄存器，也称之为累加器；
    BX (Base)：基地址寄存器；
    CX (Count)：计数器寄存器；
    DX (Data)：数据寄存器；
SP 和 BP 又称作为指针寄存器：
    SP (Stack Pointer)：堆栈指针寄存器；
    BP (Base Pointer)：基指针寄存器；
SI 和 DI 又称作为变址寄存器：
    SI (Source Index)：源变址寄存器；
    DI (Destination Index)：目的变址寄存器；

控制寄存器：

IP (Instruction Pointer)：指令指针寄存器；
FLAG：标志寄存器；

段寄存器：

CS (Code Segment)：代码段寄存器；
DS (Data Segment)：数据段寄存器；
SS (Stack Segment)：堆栈段寄存器；
ES (Extra Segment)：附加段寄存器；

第3、4章
使用NASM编译器编译。该编译器-f bin选项只出纯二进制指令，而不包含load地址，文件描述等类似于elf格式的那些信息。
使用VMware，固定大小vhd虚拟硬盘。该虚拟硬盘最简单，没有文件格式信息。
把编译出的二进制目标代码写到VHD硬盘的前512字节（也就是首个扇区，MBR），就可以让虚拟机启动时加载执行。



第5章

5.1
系统如果以硬盘启动，BIOS会把主硬盘的0面0道1扇区，也就是MBR（Main Boot Sector）的内容加载到0x0000:0x7c00。
然后检查结尾两个字节如果是0x55aa，就认为该扇区有效。扇区有效就jmp到0x0000:0x7c00处开始执行该处代码。

5.2
汇编语法中，以分号";"开始注释。

5.3
所有X86兼容机启动时，显卡都为80X25的文本模式
8086的1M地址空间，0x00000～9FFFF（640K）为普通内存。0xF0000～0xFFFFF（64K）为Rom-BIOS。
中间的320K，0xB8000～0xBFFFF（32K）是映射到上述文本模式的显卡显存的。

每个字符使用2Byte控制。前一个Byte是Ascii码，后一个Byte是显示模式。(如此说只需要80*25*2=4000，4K不到，为什么映射32K，莫非为图形做准备，或者是后面有部分空间是用来控制显卡的)。
显示模式这一个字节，从高到低共8位KRGBIRGB，低4位RGB为前景色（字体颜色），高位中的RGB为背景色。K是闪烁位，0不闪烁，1闪烁。I是亮度位，0是普通亮度，1是高亮。RGB各只有1bit，所以支持的颜色数为2^3=8种颜色。

【ds/es/cs：0x1234】这种使用方式类似于c语言的指针。但不同的是如果此形式为左值，是把内容写到该地址；如果为右值，是取该地址的内容作为右值。当段寄存器为ds时，ds：可省略。
mov a，b 既可操作8位也可操作16位。如果两个操作数都不能确定是8位还是16位，需要显示指出是byte还是word。如mov byte ax， 100。
不允许直接将立即数mov到段寄存器，只能先把值放到通用寄存器或内存，再使用通用寄存器或内存把值赋给段寄存器

5.4
汇编地址=程序加载后的段内偏移地址。每条指令有这么个地址。
每条指令前面可以加个字符串加：来生成个标号用来代表汇编地址。冒号可选的，可不加。
DB DW DD DQ 伪指令声明byte word doubleWord   quadWord，即1、2、4、8字节。可以连续声明多个，以逗号隔开。db 0x55，0xaa
div 16位除以8位。被除数在ax，除数在8位通用寄存器或内存，在内存需要显式指出除法为byte，商在al，余数在ah。（0x5050除以1这种商或余数溢出如何？）
div 32位除以16位。被除数高位在dx，低位在ax，除数在16位通用寄存器或地址，如果使用地址同样要显式指出div word。计算完成后，商在ax，余数在dx。
xor 可以对通用寄存器或内存进行8位或16位的异或操作。但不允许两个操作数都是内存。
xor ax，ax 是对ax赋0，但比mov ax ，0的目标代码短，也更快。快是因为寄存器快。

5.5
jmp 跳到某地址执行，后面的操作数是绝对地址
jmp near 后面跟的操作数是汇编地址，但是在汇编成机器码的时候汇编器会把操作数转换成目的地址与本地址的相对值
5.6
times 2 mov ax，bx 生成2次该指令
times 5 db 0xff用0xff填充5个bytes


第6章
内存批量复制 循环 条件转移 flag寄存器 nasm的$和$$

6.5
movsb和movsw，从ds：si复制一个byte/word到es：di，复制完成后，如果flag寄存器df为0，si和di会加1或2（正向复制），如果df位为1，si和di会减1或2（反向复制），配合rep指令就可批量复制
rep，如果cx不为0则执行rep后指令，同时cx减1
flag寄存器df位用cld指令清零，用std置1

6.6
loop指令，后面一个操作数，本段地址。先将cx减1，如果为0，顺序执行后面，不为0则跳到指定地址执行。类似于jmp near，生成的机器码的操作数也是一个相对值
寄存器寻址，可以把地址值放到bx si di bp ，然后通过【】访问该地址
inc指令，操作数为一个8或16的通用寄存器，或者是内存地址，使寄存器或内存的值加1。inc ax比add ax 1机器码短且速度更快

6.7
neg指令，操作数是一个8位或16位的寄存器，或是内存。对操作数求负
cbw， convert byte 2 word，没有操作数，将al扩展到ax。cwd，conver word 2 double words，将ax扩展到dx：ax。这两个指令可以应对负数可能出现的溢出。
sub指令，两个操作数为通用寄存器或内存，但不能同时为内存。处理器中加法电路和减法电路是同一套，做减法相当于是把第二操作数先neg下再add
idiv，有符号除法指令，操作数与div类似。div和idiv运算后都可能让结果的高位溢出，但是因为符号位在高位，所以idiv结果的溢出影响将把负数的符号丢失。对于idiv后的符号丢失，可以先cbw或cwd。

6.8
dec，与inc相反，减1，操作数一个8位或16位通用寄存器或者内存。
jns 条件转移，操作数和jmp near，loop类似，汇编代码中是一个段内地址，但机器码会处理成一个相对值。判断条件为FLAG寄存器的SF位，如果SF位为0则跳到指定地址，否则顺序执行。
SF sigh Flag。dec指令操作数为0时，比如AL为0x0时，DEC后0xff，SF会置位。

6.9
奇偶标志位pf parity
进位标志位cf carry
溢出标志位of overflow
辅助进位标志位af auxiliary carry 
sf
zf zero flag

已学各指令对上述位影响

条件转移指令
js/jns sf为1/0转移
jz/jnz zf
jo/jno of
jc/jnc cf 
jp/jnp pf
有没有ja/jna？

cmp指令，两个操作数，可以为8位/16位通用寄存器，或者内存，后一个操作数还可以是立即数两个操作数不能同时为内存。功能与sub指令相同，但只影响标志位而不影响操作数。
cmp后各转移指令

jcxz jump if cx is zero，一个不是care flag寄存器的条件转移指令。

6.10
nasm的$和$$。前者为本行行首汇编地址，相当于本行标号。后者为本段起始汇编地址。

第七章  最重要的新内容是栈的使用
7.5
ss stack segment 寄存器
sp stack pointer寄存器
8086的栈是从高到低增长的。ss初始化后，栈底就是【ss：0xffff】，sp初始化为0。push时，先把sp减去要push的长度，再把push的内容写到【ss：sp】。pop时先读【ss：sp】再加sp。初始化为0这里是利用了它的溢出。
push ax等效于
sub sp，2
mov bx，sp
mov 【ss：bx】，ax （为什么不能直接ss：sp？）

pop ax等效于
mov bx，sp
mov ax，【ss：bx】
add sp ，2

pop,push操作单位是16Bits 32bits等。如果操作数是内存，需要指明是word等。

or指令和and指令。两个操作数，可以是通用寄存器或内存，不能同时为内存，后一个可以是立即数，结果放在第一个操作数

7.7 寻址方式
寄存器寻址 立即寻址（立即数寻址）内存寻址
内存寻址又分为直接寻址（地址数字或标号） 基址寻址（bx或bp） 变址寻址（di或si） 基址变址寻址（bx或bp+di或si）

第8章
SECTION和SEGMENT 接口访问in/out指令 硬盘访问 call ret/retf
8.2
使用SECTION或SEGMENT来定义段
aligh=指定段对齐方式8086要求至少16位对齐
section.段名称.start可直接在程序中使用，代表段起始地址
默认情况下，段内定义的标号是从程序开始处算偏移的。如果在定义段时有vstart=0，标号就是从本段开始0处算偏移。另一方面，如果vstart和加载地址相同，那段内的汇编地址就和运行地址相同了。
用户程序的需要有个header来向加载器描述程序的大体情况。需要有程序长度（32位）、段重定位表、程序入口（需要段和段内偏移，都是指汇编地址）。实际上这里是定义了一个简化版的coffe格式

8.3
imaconst equal 100。equal 伪指令，定义一个常量imaconst，值是100。不同意db dd等，equal不但不生成机器码，连内存也不占用。只是在后面引用这个常量的时候换成相应的值。
？留个疑问，在CPU加载MBR程序跳到0x7c00时，CS寄存器为0。

ICH (i/o controller hub),PC上所谓的南桥就是ICH芯片，提供USB SATA LPC 时钟 PATA（IDE）等接口。（北桥芯片紧挨CPU，RAM和南桥芯片通过北桥来连接CPU，数据量很大）

端口可以与内存共享地址空间，也可以独立编址。独立编址的系统中，CPU提供一个引脚来控制地址线是访问内存的还是访问端口的。Intel早期是独立编址的，现在都支持。
x86系统中，使用16位给端口编号（编址），因此最多支持65536个端口。
每个PATA/SATA接口包含8个端口，不同的端口用来读写状态等等。X86系统中的ICH提供两套PATA/SATA接口，来支持master和slave两块硬盘。master硬盘的8个端口为0x1f0-0x1f7，slave的8个端口为0x170-0x177。
in out指令使用有两种形式，一种是把端口地址写到DX，然后in al/ax, dx(和out dx al/ax)，一种是 in al/ax 0xx(和out 0xx，al/ax)。前者生成1字节指令，后者生成1字节指令+1字节立即数。立即数只有1字节，所以后者不能访问大于255的端口
LBA28方式读主硬盘，0x1f0为数据出端口，这一组端口里唯一的16位端口。0x1f1为错误端口。0x1f2写入要读写多少个扇区。0x1f3、0x1f4、0x1f5、0x1f6的低四位放28位的起始扇区号。0x1f6的4位0表示master盘，1表示slave盘，高3位全1表示lba。0x1f7写0x20表示请求读，7位为1表示忙，3位是ready位为1表示处理好了。完整的过程为，先把要读的扇区数目起始扇区号写入相应端口，然后请求读，硬盘就会将0x1f7忙位置1，读好后，ready位为1，最后程序就可以连续从0x1f0读取数据了。
call 分为4类
16位相对近调用，call near 标号，near可省略。编译后机器码三字节指令，一个操作码0xe8和两字节的相对偏移（与jmp near等类似，标号代表的段内偏移会在编译时被处理为相对偏移）。16位相对偏移为有符号值，因此被调过程需要距当前-32768～32767字节。执行时先push ip，然后把要跳转的段内偏移（当然是把原ip加上）写到ip。
16位间接绝对近调用，call cx，或call [bx],或call [0x3000]等。不同的寻址方式对应了不同的机器码。也是段内，比相对近调用的好处是没有那个与本处距离的要求。应该是先push ip，再把段内偏移写到ip。
16位直接绝对远调用。call 0x2000:0x0030, 编译后机器码为9A，后面偏移地址和段地址。执行时，自动push cs，push ip，然后分别把段地址和偏移填写进CS和IP。
16位间接绝对远调用，call far [0xxxxx(或标号)]，或者 call far [bx]，或者 call far [bx+si].是要先把过程的段地址和段偏移（共4字节）写到某内存，再call far 指定该内存 。执行时，先从call far后面指定的地方把段地址和段偏移取出，然后push cs，push ip，最后用段地址和段偏移替换cs和ip。

ret和retf分别对应call near和call far。ret是pop两个字节到ip，retf是pop ip，pop cs。

adc 带进位的加法。adc A, B 相当于A+B+CF。如果这条指令前面有AB低位的add或adc，那就将前面低位的进位累加进去。
shr/shl 右移/左移，SHift logical Right/Left。每移1位，该位会放入CF。
ror/rol  循环右移/左移，ROtate Right/Left。每移1位，该位也会放入CF。

jmp short  立即数  相对短跳转，机器码相对值只有1字节
jmp near  立即数    相对近跳转，机器码相对值有2字节
jmp near 寄存器/mem 间接绝对近跳转，跳到同一段某地址去，地址在REG或[mem]
jmp 立即数:立即数  直接绝对远跳转
jmp far []                  相对间接远跳转

8.4
resb resw resd 伪指令，后面跟个数字保留相应个byte/word/dword
显卡索引寄存器端口号0x3d4，写入14(0x0e)和15(0x0f)，用于访问两个8bits寄存器，分别提供光标位置的高8位和低8位。指定寄存器后，通过读写数据端口0x3d5来访问两个8位寄存器。
8.4.10演示了一个把要跳转的地址push进栈再ret/retf，同样可以达到跳转的目的。

第9章 中断

    9.1外部硬件中断，NMI和inerrupt；9.2内部中断，除数为0、无效指令等；9.3软中断，int指令触发

9.1
NMI (Non Maskable Interrupt)中断号为2，一般为灾难性的硬件错误。CPU上有一个专门的引脚NMI。

可屏蔽中断，通过CPU引脚INTR引入处理器内部。引脚只有一个，为了能处理不同中断，X86使用两个8259芯片代理中断。每个8259有8个中断输入引脚（0-7），两个级联（cascade）可处理15个不同中断。从片输出接到主片的引脚2上。主片0引脚接系统定时器/计数器，从片0接实时时钟（RTC）和CMOS Ram。主片输出接到X86处理器的INTR引脚
8259内部有8bits中断屏蔽寄存器（IMR），每位分别对应一个输入引脚。1为屏蔽，0为允许。
主片通过端口号0x20/0x21访问，从片通过端口号0xa0/0xa1访问。
Flag寄存器中的IF位为0时，处理器不理会INTR。cli(clear interrupt)和sti(set interrupt)用来设置Flag的IF位。
8259优先级： 0 >1 ....>7。低优先级中断事件处理会被更高中断事件中断，是谓中断嵌套。

X86支持256个中断（编号为0-255）。实模式中断向量表(interrupt vector table， IVT)从0x0开始，每个表项4Bytes，整个表使用1Kbytes（0x0-0x3ff）。
编程控制8259芯片引脚号与中断号的关系，单片编号连续的。

中断处理过程1、PUSH Flags，清除IF位和TF（trap）位，PUSH CS和IP。2、找到对应中断表项，把中断程序的偏移地址和段地址分别传送至IP CS，处理程序执行。3、Iret返回，POP IP、CS、Flags。其中3中Iret是程序员在中断处理程序里设置的，另外两步是处理器自动处理的。因为IF会被清除，所以如果希望中断嵌套的话需要在中断处理程序中cli。

10.1
AX、BX、CX、DX、SI、DI、BP、SP---->EAX、EBX、ECX……
但CS、DS、SS、ES没有E版本，还是16位。但是含义变了，不是段寄存器了，是段选择寄存器。而且多了FS和GS，和ES一样，是附加的。
MOV、ADD等指令可以像操作16位寄存器一样来操作32位寄存器。但16位和32位寄存器不能滥用。



提个疑问，自动修改IP或EIP等寄存器的指令，像ret等，怎么知道要操作的是IP还是EIP。
答案是“操作数大小的指令前缀0x66”吗


chater11


全局描述符表 GDT，每个表项8字节，32位段基址，20位界限，以及其他权限啊等等零散的12位
G（1） 粒度，0指字节，1指4KB
S（1）为0时，表示是系统段，1时是代码段
DPL（2）0-4的特权级别。CPU由CR0里的两位决定了当前的0-4级别，越小权限越大。一段内存只能由高于等于DPL的CPU访问。
P（1）段存在位，1代表在内存中，0代表不在
D/B（1）对代码段来说叫D位，为1时，表示32位的地址或操作数，如使用EIP，否则使用EIP。对堆栈段来说叫B位，为1时PUSH、POP等堆栈操作使用ESP，否则使用SP
L（1），64位代码段标志
TYPE（4）  对于数据是XEWA，对于代码是XCRA，X位，可执行，W，可写，R，可否被程序读，A，已访问，E，扩展方向，0向上（普通数据段），1向下，通常堆栈，C是否依从代码特权
AVL（1），软件随便用。
第一个表项的8字节要求全0。


GDTR 48位的GDT寄存器，32位基地址，16位边界，边界是到基地址的byte偏移。
GDTR的32位基地址是什么地址？线性地址！

lgdt 指令把从一个指定地址开始，copy 48位到GDTR里去

A20问题，80486以后，将0x92端口读出，位1设置成1，再写回，就可打开A20


CR0 的bit0设置为1，就运行在保护模式了。

保护模式的中断向量表和实模式不一样（bios中断都不可以用）。是因为16位和32位的原因吗？
需要在进入保护模式时先关中断。



保护模式下，DS不再解释为段寄存器，而是解释为段选择子。16位，1位TI，为0表示GDT，为1表示LDT；2位RPL，给出当前选择子的程序运行级别。其中13位是描述符索引。GDT界限是16位的，但含意是GDT一共多少字节，每个表项是8字节，所以是65536/8=8192个表项，刚好13位。



需要用JMP来清空流水线，JMP编译成16位，但JMP的target就应该是32位了。



